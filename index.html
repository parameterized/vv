<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>vv</title>
<link rel="shortcut icon" href='data:image/svg+xml,
    <svg xmlns=%22http://www.w3.org/2000/svg" viewBox="0 0 100 100">
    <text y="1.1em" font-size="75">üå±Ô∏è</text></svg>'>
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<style>
    * { box-sizing: border-box; }
    body {
        margin: 0;
        overflow: hidden;
        background: #523f38;
        touch-action: none;
    }
    canvas {
        position: absolute;
        display: block;
        width: 100dvw;
        height: 100dvh;
        -webkit-tap-highlight-color: transparent;
    }
</style>
</head>

<body>
<canvas ondragstart="return false"></canvas>
<script>
let {
    min, max, abs, sign, sqrt, pow, exp, sin, cos, tan, atan2
} = Math
let pi = Math.PI

let clamp = (x, a, b) => min(max(x, a), b)
let dist = (x1, y1, x2=0, y2=0) => sqrt((x2 - x1)**2 + (y2 - y1)**2)
let lerp = (a, b, t) => a * (1 - t) + b * t
let fri_lerp = (a, b, t, dt) => {
    let alpha = 1 - exp(-60 * t * dt)
    return lerp(a, b, alpha)
}

let ease = {
    outQuart: t => 1 - pow(1 - t, 4),
    outBounce: t => {
        let n1 = 7.5625,  d1 = 2.75
        if (t < 1 / d1) return n1 * t * t
        else if (t < 2 / d1)
            return n1 * (t -= 1.5 / d1) * t + 0.75
        else if (t < 2.5 / d1)
            return n1 * (t -= 2.25 / d1) * t + 0.9375
        else return n1 * (t -= 2.625 / d1) * t + 0.984375
    }
}

let cursor = v => document.body.style.cursor = v

let mouse = {
    x: 0, y: 0,
    xv: 0, yv: 0,
    held: { 0: false, 1: false, 2: false },
    moved: false,
}

let mouse_held = btn => {
    if (btn == undefined) {
        for (let b in mouse.held)
        if (mouse.held[b]) return true
        return false
    }
    return btn in mouse.held && mouse.held[btn]
}

onwheel = e => {
    let _s = cam.s
    cam.s *= exp(-e.deltaY / 1000)
    let f = 1 / _s - 1 / cam.s
    let w = canvas.width,  h = canvas.height
    cam.x += (mouse.x - w / 2) * f
    cam.y += (mouse.y - h / 2) * f
}

oncontextmenu = e => e.preventDefault()

let wmx = 0,  wmy = 0
let set_wmouse = () => {
    let m = ctx.getTransform().inverse()
    let { x, y } = m.transformPoint(mouse)
    wmx = x,  wmy = y
}

let set_held = obj => {
    held.obj = obj
    held.start_x = wmx,  held.start_y = wmy
    held.moved = false
}

let ui_press = (x, y) => {
    mouse.x = x,  mouse.y = y
    mouse.xv = 0,  mouse.yv = 0
    set_wmouse()

    for (let a of atoms)
    if (dist(a.x, a.y, wmx, wmy) < 25)
    set_held(a)

    if (held.obj) return

    for (let vv of [...vvs])
    vv.press()

    if (!held.obj) set_held(cam)
}

let ui_release = () => {
    let h = held.obj
    if (!h) return

    if (h instanceof Atom) {
        if (held.moved) h.drop()
        else h.tap()
    }

    let xv = mouse.xv / cam.s,  yv = mouse.yv / cam.s
    if (h == cam) { xv *= -1,  yv *= -1 }
    h.xv = xv,  h.yv = yv
    held.obj = null
}

let ui_move = (x, y, dx, dy) => {
    mouse.x = x,  mouse.y = y
    mouse.xv = fri_lerp(mouse.xv, dx / dt, 0.2, dt)
    mouse.yv = fri_lerp(mouse.yv, dy / dt, 0.2, dt)

    if (held.obj == cam && fingers.size < 2) {
        cam.x -= dx / cam.s
        cam.y -= dy / cam.s
        cam.xv = -mouse.xv / cam.s
        cam.yv = -mouse.yv / cam.s
    }
}

let fingers = new Map()
let touched = false
let touch_left = () => (
    touched !== false && !fingers.has(touched)
)

onblur = () => fingers.clear()

onpointerdown = e => {
    let dpr = devicePixelRatio
    let x = e.clientX * dpr,  y = e.clientY * dpr

    if (e.pointerType == "touch") {
        fingers.set(e.pointerId, { x, y })
        if (e.isPrimary) touched = e.pointerId
    }

    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = true
    }
    ui_press(x, y)
}

onpointerup = e => {
    fingers.delete(e.pointerId)

    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = false
    }
    ui_release()
}

onpointermove = e => {
    let dpr = devicePixelRatio
    let x = e.clientX * dpr,  y = e.clientY * dpr

    let pid = e.pointerId
    let ids = [...fingers.keys()]
    if (fingers.has(pid) && ids.length == 2) {
        let { x: _x, y: _y } = fingers.get(pid)
        let f2 = fingers.get(ids[ids[0] == pid ? 1 : 0])
        let mdx = (x - _x) / 2,  mdy = (y - _y) / 2
        let md = dist(mdx, mdy)
        let tdx = _x - f2.x,  tdy = _y - f2.y
        let td = dist(tdx, tdy)
        let dp = (mdx * tdx + mdy * tdy) / max(md * td, 0.01)
        let dpf = 1 - abs(dp)
        cam.x -= mdx * dpf / cam.s
        cam.y -= mdy * dpf / cam.s

        let d1 = dist(f2.x, f2.y, _x, _y)
        let d2 = dist(f2.x, f2.y, x, y)
        let _s = cam.s
        cam.s *= d2 / d1
        let f = 1 / _s - 1 / cam.s
        let w = canvas.width,  h = canvas.height
        cam.x += (f2.x - w / 2) * f
        cam.y += (f2.y - h / 2) * f
    }
    let fp = fingers.get(pid)
    if (fp) { fp.x = x,  fp.y = y }

    if (e.isPrimary)
    ui_move(x, y, e.movementX * dpr, e.movementY * dpr)
}

let keydown = {}

onkeydown = e => {
    let key = e.key.toLowerCase()
    if (e.repeat || e.ctrlKey) return
    keydown[key] = true

    if (key == "r") init()
    if ("df".includes(key)) ui_press(mouse.x, mouse.y)
}

onkeyup = e => {
    let key = e.key.toLowerCase()
    keydown[key] = false

    if ("df".includes(key)) ui_release()
}

let rng = (a, b) => {
    let arr = new Uint32Array(1)
    crypto.getRandomValues(arr)
    let v = arr[0] / 0xffffffff
    if (a == undefined) return v
    if (b == undefined) return v * a
    return a + v * (b - a)
}
let rngc = (r) => {
    let a = rng(2 * pi)
    return [r * cos(a), r * sin(a)]
}

let canvas = document.querySelector("canvas")
let ctx = canvas.getContext("2d")

let line = (x1, y1, x2, y2, strokeStyle) => {
    ctx.strokeStyle = strokeStyle || ctx.strokeStyle
    ctx.beginPath()
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.stroke()
}

let circle = (x, y, r, color = "SteelBlue", mode = "fill") => {
    ctx.lineWidth = 4
    if (mode == "fill") ctx.fillStyle = color
    else ctx.strokeStyle = color
    ctx.beginPath()
    ctx.ellipse(
        x, y, r, r,
        0, 0, pi * 2,
    )
    if (mode == "fill") ctx.fill()
    else ctx.stroke()
}

let _mats = []
let push = () => _mats.push(ctx.getTransform())
let pop = () => ctx.setTransform(_mats.pop())

let bond = (a1, a2) => {
    let a12 = [a1, a2]
    for (let i = 0; i < 2; i++) {
        bonds.set(a12[i], bonds.get(a12[i]) || new Set())
        let s = bonds.get(a12[i])
        if (!s.delete(a12[1 - i])) s.add(a12[1 - i])
    }

    let a1s = bonds.get(a1),  a2s = bonds.get(a2)
    if (!a1.fill && a1s.has(a2)
        || !a2.fill && a2s.has(a1)
    ) { a1.rm(),  a2.rm() }

    bonding = bonding.filter(v => !a12.includes(v))
}

class Atom {
    x = 0; y = 0; xv = 0; yv = 0
    r = 25
    target_dist = 100

    constructor(fill) {
        this.fill = fill
    }

    rm() {
        let a = this
        let i = atoms.indexOf(a)
        if (i < 0) return
        atoms.splice(i, 1)
        let s = bonds.get(a)
        if (!s) return
        for (let a2 of s) bonds.get(a2).delete(a)
        s.clear()
    }

    update(dt) {
        let a = this
        if (a == held.obj) return

        a.xv = fri_lerp(a.xv, 0, 0.1, dt)
        a.yv = fri_lerp(a.yv, 0, 0.1, dt)
        a.x += a.xv * dt
        a.y += a.yv * dt

        let s = bonds.get(a)
        if (!s || !s.size) return
        let tdx = 0,  tdy = 0
        for (let a2 of s) {
            let dx = a.x - a2.x,  dy = a.y - a2.y
            let d = dist(dx, dy)
            let td = sqrt(a.target_dist * a2.target_dist)
            let tx = a2.x + dx * td / d
            let ty = a2.y + dy * td / d
            tdx += tx - a.x,  tdy += ty - a.y
        }
        tdx /= s.size,  tdy /= s.size
        a.x = fri_lerp(a.x, a.x + tdx, 0.5, dt)
        a.y = fri_lerp(a.y, a.y + tdy, 0.5, dt)
    }

    tap() {
        let a = this,  b = bonding
        if (b.includes(a)) bonding = b.filter(v => v != a)
        else b.push(a)

        if (b.length == 2) bond(...b)
    }

    drop() {
        let a = this
        for (let a2 of atoms) {
            if (a2 == a) continue
            if (dist(wmx, wmy, a2.x, a2.y) < a2.r)
            { bond(a, a2); break }
        }
    }

    draw() {
        let a = this
        let fill = a.fill
        let r = a.r || 25
        if (dist(a.x, a.y, wmx, wmy) < r && !touch_left())
        { cursor("pointer"),  fill = "#577" }
        if (fill) circle(a.x, a.y, r, fill)
        else circle(a.x, a.y, r, "#122", "line")
        if (bonding.includes(a)) {
            circle(a.x, a.y, r * 1.3, "#122", "line")
        }
    }
}

let add_atom = fill => {
    let a = new Atom(fill)
    atoms.push(a)
    return a
}

class VV {
    a = 0; s = 1
    alive = true
    open = true
    open_t = 0

    btns = {
        toggle: {
            fn: () => this.open = !this.open,
            x: 0, y: 0, fill: "#688",
        },
        rm: {
            fn: () => {
                this.open = false,  this.alive = false
                this.ts = 0
            },
            x: -65, y: 0, fill: "#122",
        },
        copy: {
            fn: () => {
                let vv2 = new VV(this.x, this.y)
                vvs.push(vv2)
                vv2.yv = rng(6000, 10000)
                vv2.xv = rng(-2000, 2000)
            },
            x: 65, y: 0, fill: "#bcd",
        },
        red: {
            fn: () => set_held(add_atom("#a33")),
            x: cos(-2 * pi / 3) * 65, y: sin(-2 * pi / 3) * 65,
            fill: "#a33",
        },
        green: {
            fn: () => set_held(add_atom("#285")),
            x: cos(-pi / 3) * 65, y: sin(-pi / 3) * 65,
            fill: "#285",
        },
        blue: {
            fn: () => set_held(add_atom("#279")),
            x: cos(2 * pi / 3) * 65, y: sin(2 * pi / 3) * 65,
            fill: "#279",
        },
        none: {
            fn: () => set_held(add_atom()),
            x: cos(pi / 3) * 65, y: sin(pi / 3) * 65,
        },
    }

    constructor(x = 0, y = 0) {
        let vv = this
        vv.x = x,  vv.y = y
        let [xv, yv] = rngc(300)
        vv.xv = xv,  vv.yv = yv
        vv.av = rng(0.2, 0.8) * sign(rng(-1, 1))
    }

    update(dt) {
        let vv = this
        vv.xv = fri_lerp(vv.xv, 0, 0.15, dt)
        vv.yv = fri_lerp(vv.yv, 0, 0.15, dt)
        vv.av = fri_lerp(vv.av, 0, 0.15, dt)
        vv.x += vv.xv * dt
        vv.y += vv.yv * dt
        vv.a += vv.av * dt

        if (vv.alive)
        vv.ts = 0.75 + 1 / (3 + exp(sqrt(vv.xv**2 + vv.yv**2) / 200))
        else if (vv.s < 0.01)
        vvs.splice(vvs.indexOf(this), 1)

        vv.s = fri_lerp(vv.s, vv.ts, 0.15, dt)

        vv.open_t = clamp(
            vv.open_t + (vv.open ? 1 : -1) * 2 * dt,
            0, 1
        )
    }

    press() {
        let vv = this
        push()
        ctx.translate(vv.x, vv.y)
        ctx.rotate(vv.a)
        ctx.scale(vv.s, vv.s)

        let btn_slide_t = (vv.open
            ? ease.outQuart(vv.open_t)
            : 1 - ease.outQuart(1 - vv.open_t)
        )
        let btn_roll_t = 1 - btn_slide_t

        ctx.translate(0, 120 * btn_slide_t)
        ctx.rotate(-pi * btn_roll_t)
        let s = lerp(1, 1.6, btn_slide_t)
        ctx.scale(s, s)

        let m = ctx.getTransform().inverse()
        let { x: mx, y: my } = m.transformPoint(mouse)

        for (let b of Object.values(vv.btns))
        if (dist(b.x, b.y, mx, my) < 25) b.fn()

        pop()
    }

    draw() {
        let vv = this
        push()
        ctx.translate(vv.x, vv.y)
        ctx.rotate(vv.a)
        ctx.scale(vv.s, vv.s)

        let slide_t = (vv.open
            ? ease.outBounce(vv.open_t)
            : 1 - ease.outBounce(1 - vv.open_t)
        )
        let roll_t = 1 - slide_t
        let btn_slide_t = (vv.open
            ? ease.outQuart(vv.open_t)
            : 1 - ease.outQuart(1 - vv.open_t)
        )
        let btn_roll_t = 1 - btn_slide_t

        let h = tan(pi / 3) * 200
        let mid = tan(pi / 6) * 200

        ctx.lineWidth = 100

        push()
        ctx.translate(300 * slide_t, 0)
        ctx.rotate(-pi / 2 * roll_t)
        ctx.translate(0, -mid)
        line(-200, 0, 200, 0, "#4d3b34")
        line(-200, 0, 0, h, "#47352f")
        line(0, h, 200, 0)
        pop()

        push()
        ctx.translate(-300 * slide_t, 0)
        ctx.rotate(pi / 2 * roll_t)
        ctx.translate(0, -mid)
        line(-200, 0, 200, 0, "#4d3b34")
        line(-200, 0, 0, h, "#47352f")
        line(0, h, 200, 0)
        pop()

        ctx.translate(0, 120 * btn_slide_t)
        ctx.rotate(-pi * btn_roll_t)
        let s = lerp(1, 1.6, btn_slide_t)
        ctx.scale(s, s)

        let m = ctx.getTransform().inverse()
        let _wmx = wmx,  _wmy = wmy
        let { x, y } = m.transformPoint(mouse)
        wmx = x,  wmy = y

        for (let b of Object.values(vv.btns))
        Atom.prototype.draw.call(b)

        wmx = _wmx,  wmy = _wmy

        pop()
    }
}

let cam, held, bonding
let vvs, atoms, bonds
let init = () => {
    cam = {
        x: 0, y: 0, xv: 0, yv: 0,
        s: canvas.width / 1600,
    }
    held = {}
    bonding = []

    vvs = [new VV(0, -30)]
    atoms = []
    bonds = new Map()
}

onload = () => {
    init()
    loop()
}

onresize = () => {
    let dpr = devicePixelRatio
    let w = innerWidth * dpr,  h = innerHeight * dpr
    if (cam) cam.s *= w / canvas.width
    canvas.width = w,  canvas.height = h
}
onresize()

let update = dt => {
    mouse.xv = fri_lerp(mouse.xv, 0, 0.3, dt)
    mouse.yv = fri_lerp(mouse.yv, 0, 0.3, dt)

    let h = held.obj
    if (h != cam) {
        if (h) {
            h.x = wmx,  h.y = wmy
            let dx = h.x - held.start_x
            let dy = h.y - held.start_y
            if (dist(dx, dy) > 10) held.moved = true
        }

        cam.xv = fri_lerp(cam.xv, 0, 0.05, dt)
        cam.yv = fri_lerp(cam.yv, 0, 0.05, dt)
        cam.x += cam.xv * dt
        cam.y += cam.yv * dt
    }

    if (!vvs.length) vvs = [new VV(0, -30)]
    for (let vv of [...vvs]) vv.update(dt)
    for (let a of atoms) a.update(dt)
}

let draw = () => {
    ctx.lineCap = "round"
    ctx.lineJoin = "round"
    for (let vv of vvs) vv.draw()

    ctx.strokeStyle = "#122"
    for (let [a1, a2s] of bonds.entries()) {
        for (let a2 of a2s) {
            line(a1.x, a1.y, a2.x, a2.y)
        }
    }

    for (let a of atoms) a.draw()
}

let now = () => performance.now()
let _time = now()
let dt = 0

let loop = () => {
    dt = min((now() - _time) / 1000, 0.1)
    _time = now()

    ctx.resetTransform()
    let w = canvas.width,  h = canvas.height
    ctx.clearRect(0, 0, w, h)
    ctx.translate(w / 2, h / 2)
    ctx.scale(cam.s, cam.s)
    ctx.translate(-cam.x, -cam.y)
    set_wmouse()
    cursor("default")

    update(dt)
    draw()

    requestAnimationFrame(loop)
}
</script>
</body>
</html>
