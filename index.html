<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>vv</title>
<link rel="shortcut icon" href='data:image/svg+xml,
    <svg xmlns=%22http://www.w3.org/2000/svg" viewBox="0 0 100 100">
    <text y="1.1em" font-size="75">üå±Ô∏è</text></svg>'>
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<style>
    * { box-sizing: border-box; }
    body {
        margin: 0;
        overflow: hidden;
        background: #523f38;
    }
    canvas { position: absolute; }
</style>
</head>

<body>
<canvas ondragstart="return false"></canvas>
<script>
let { min, max, abs, sign, sqrt, exp, sin, cos, tan, atan2 } = Math
let pi = Math.PI

let clamp = (x, a, b) => min(max(x, a), b)
let dist = (x1, y1, x2, y2) => sqrt((x2 - x1)**2 + (y2 - y1)**2)
let lerp = (a, b, t) => a * (1 - t) + b * t
let fri_lerp = (a, b, t, dt) => {
    let alpha = 1 - exp(-60 * t * dt)
    return lerp(a, b, alpha)
}

let ease = {
    outQuad: t => t * (2 - t),
    outBounce: t => {
        let n1 = 7.5625,  d1 = 2.75
        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }
}

let cursor = v => document.body.style.cursor = v

let mouse = {
    x: 0, y: 0,
    held: { 0: false, 1: false, 2: false },
    moved: false,
}
mouse_held = btn => {
    if (btn == undefined) {
        for (let b in mouse.held)
        if (mouse.held[b]) return true
        return false
    }
    return btn in mouse.held && mouse.held[btn]
}
onpointermove = e => {
    if (!e.isPrimary) return
    mouse.x = e.clientX
    mouse.y = e.clientY
    mouse.moved = true

    if (keydown.f || mouse_held(2)) {
        cam.x -= e.movementX / cam.s
        cam.y -= e.movementY / cam.s
    }
}
onwheel = e => {
    let _s = cam.s
    cam.s *= exp(-e.deltaY / 1000)
    let f = 1 / _s - 1 / cam.s
    let [w, h] = [innerWidth, innerHeight]
    cam.x += (mouse.x - w / 2) * f
    cam.y += (mouse.y - h / 2) * f
}
oncontextmenu = e => e.preventDefault()
onpointerdown = e => {
    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = true
    }
    mouse.x = e.clientX
    mouse.y = e.clientY
    mouse.moved = true

    for (let vv of [...vvs]) vv.mousedown()
}
onpointerup = e => {
    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = false
    }
}

let keydown = {}
onkeydown = e => {
    let key = e.key.toLowerCase()
    if (e.repeat || e.ctrlKey) return
    keydown[key] = true

    switch (key) {
        case "r": init(); break
    }
    for (let vv of [...vvs]) vv.keydown(key)
}
onkeyup = e => {
    let key = e.key.toLowerCase()
    keydown[key] = false
}

let rng = (a, b) => {
    let arr = new Uint32Array(1)
    crypto.getRandomValues(arr)
    let v = arr[0] / 0xffffffff
    if (a == undefined) return v
    if (b == undefined) return v * a
    return a + v * (b - a)
}
let rngc = (r) => {
    let a = rng(2 * pi)
    return [r * cos(a), r * sin(a)]
}

let canvas = document.querySelector("canvas")
let ctx = canvas.getContext("2d")

let cam, vvs

let line = (x1, y1, x2, y2, strokeStyle) => {
    ctx.strokeStyle = strokeStyle || ctx.strokeStyle
    ctx.beginPath()
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.stroke()
}

let circle = (x, y, r, fillStyle = "SteelBlue") => {
    ctx.fillStyle = fillStyle
    ctx.beginPath()
    ctx.ellipse(
        x, y, r, r,
        0, 0, pi * 2,
    )
    ctx.fill()
}

let _mats = []
let push = () => _mats.push(ctx.getTransform())
let pop = () => ctx.setTransform(_mats.pop())

class VV {
    a = 0; s = 1
    alive = true
    open = true
    open_t = 0

    constructor(x, y) {
        let vv = this
        vv.x = x,  vv.y = y
        let [xv, yv] = rngc(300)
        vv.xv = xv,  vv.yv = yv
        vv.av = rng(0.2, 0.8) * sign(rng(-1, 1))
    }

    update(dt) {
        let vv = this
        vv.xv = fri_lerp(vv.xv, 0, 0.15, dt)
        vv.yv = fri_lerp(vv.yv, 0, 0.15, dt)
        vv.av = fri_lerp(vv.av, 0, 0.15, dt)
        vv.x += vv.xv * dt
        vv.y += vv.yv * dt
        vv.a += vv.av * dt

        if (vv.alive)
        vv.ts = 0.75 + 1 / (3 + exp(sqrt(vv.xv**2 + vv.yv**2) / 200))
        else if (vv.s < 0.01)
        vvs.splice(vvs.indexOf(this), 1)

        vv.s = fri_lerp(vv.s, vv.ts, 0.15, dt)

        vv.open_t = clamp(
            vv.open_t + (vv.open ? 1 : -1) * 2 * dt,
            0, 1
        )
    }

    mousedown() {
        let vv = this
        push()
        ctx.translate(vv.x, vv.y)
        ctx.rotate(vv.a)
        ctx.scale(vv.s, vv.s)

        let m = ctx.getTransform().inverse()
        let {x, y} = m.transformPoint(mouse)

        if (dist(x, y, -65, 0) < 25) {
            vv.open = false
            vv.alive = false
            vv.ts = 0
        } else if (dist(x, y, 0, 0) < 25) {
            vv.open = !vv.open
        } else if (dist(x, y, 65, 0) < 25) {
            let vv2 = new VV(this.x, this.y)
            vvs.push(vv2)
            vv2.yv = rng(6000, 10000)
            vv2.xv = rng(-2000, 2000)
        }
        pop()
    }

    keydown(key) {
        if (key != "d") return
        this.mousedown()
    }

    draw() {
        let vv = this
        push()
        ctx.translate(vv.x, vv.y)
        ctx.rotate(vv.a)
        ctx.scale(vv.s, vv.s)

        let slide_t = (vv.open
            ? ease.outBounce(vv.open_t)
            : 1 - ease.outBounce(1 - vv.open_t)
        )
        let roll_t = 1 - slide_t
        let h = tan(pi / 3) * 200
        let mid = tan(pi / 6) * 200

        push()
        ctx.translate(300 * slide_t, 0)
        ctx.rotate(pi / 6 * roll_t)
        ctx.translate(0, -mid)
        line(-200, 0, 200, 0, "#4d3b34")
        line(-200, 0, 0, h, "#47352f")
        line(0, h, 200, 0)
        pop()

        push()
        ctx.translate(-300 * slide_t, 0)
        ctx.rotate(-pi / 6 * roll_t)
        ctx.translate(0, -mid)
        line(-200, 0, 200, 0, "#4d3b34")
        line(-200, 0, 0, h, "#47352f")
        line(0, h, 200, 0)
        pop()

        let m = ctx.getTransform().inverse()
        let {x, y} = m.transformPoint(mouse)

        let fill = "#122"
        if (dist(x, y, -65, 0) < 25)
        { cursor("pointer"),  fill = "#577" }
        circle(-65, 0, 25, fill)

        fill = "#688"
        if (dist(x, y, 0, 0) < 25)
        { cursor("pointer"),  fill = "#577" }
        circle(0, 0, 25, fill)

        fill = "#bcd"
        if (dist(x, y, 65, 0) < 25)
        { cursor("pointer"),  fill = "#577" }
        circle(65, 0, 25, fill)

        pop()
    }
}

let init = () => {
    cam = { x: 0, y: 0, s: 1 }
    vvs = [new VV(0, 0)]
}

onload = () => {
    init()
    loop()
}

onresize = () => {
    canvas.width = innerWidth
    canvas.height = innerHeight
}
onresize()

let update = dt => {
    for (let vv of [...vvs]) vv.update(dt)
}

let draw = () => {
    ctx.resetTransform()
    let [w, h] = [innerWidth, innerHeight]
    ctx.clearRect(0, 0, w, h)
    cursor("default")

    ctx.translate(w / 2, h / 2)
    ctx.scale(cam.s, cam.s)
    ctx.translate(-cam.x, -cam.y)
    push()

    ctx.lineWidth = 100
    ctx.lineCap = "round"
    ctx.lineJoin = "round"
    for (let vv of vvs) vv.draw()

    pop()
}

let now = () => performance.now()
let _time = now()

let loop = () => {
    let dt = min((now() - _time) / 1000, 0.1)
    _time = now()

    update(dt)
    draw()

    requestAnimationFrame(loop)
}
</script>
</body>
</html>
