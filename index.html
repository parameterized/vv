<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>vv</title>
<link rel="shortcut icon" href='data:image/svg+xml,
    <svg xmlns=%22http://www.w3.org/2000/svg" viewBox="0 0 100 100">
    <text y="1.1em" font-size="75">üå±Ô∏è</text></svg>'>
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<style>
    * { box-sizing: border-box; }
    body {
        margin: 0;
        overflow: hidden;
        background: #523f38;
        touch-action: none;
    }
    canvas {
        position: absolute;
        display: block;
        width: 100dvw;
        height: 100dvh;
        -webkit-tap-highlight-color: transparent;
    }
</style>
</head>

<body>
<canvas ondragstart="return false"></canvas>
<script>
let { min, max, abs, sign, sqrt, exp, sin, cos, tan, atan2 } = Math
let pi = Math.PI

let clamp = (x, a, b) => min(max(x, a), b)
let dist = (x1, y1, x2=0, y2=0) => sqrt((x2 - x1)**2 + (y2 - y1)**2)
let lerp = (a, b, t) => a * (1 - t) + b * t
let fri_lerp = (a, b, t, dt) => {
    let alpha = 1 - exp(-60 * t * dt)
    return lerp(a, b, alpha)
}

let ease = {
    outQuad: t => t * (2 - t),
    outBounce: t => {
        let n1 = 7.5625,  d1 = 2.75
        if (t < 1 / d1) return n1 * t * t
        else if (t < 2 / d1)
            return n1 * (t -= 1.5 / d1) * t + 0.75
        else if (t < 2.5 / d1)
            return n1 * (t -= 2.25 / d1) * t + 0.9375
        else return n1 * (t -= 2.625 / d1) * t + 0.984375
    }
}

let cursor = v => document.body.style.cursor = v

let mouse = {
    x: 0, y: 0,
    xv: 0, yv: 0,
    held: { 0: false, 1: false, 2: false },
    moved: false,
}

let mouse_held = btn => {
    if (btn == undefined) {
        for (let b in mouse.held)
        if (mouse.held[b]) return true
        return false
    }
    return btn in mouse.held && mouse.held[btn]
}

onwheel = e => {
    let _s = cam.s
    cam.s *= exp(-e.deltaY / 1000)
    let f = 1 / _s - 1 / cam.s
    let w = canvas.width,  h = canvas.height
    cam.x += (mouse.x - w / 2) * f
    cam.y += (mouse.y - h / 2) * f
}

oncontextmenu = e => e.preventDefault()

let ui_press = (x, y) => {
    mouse.x = x,  mouse.y = y
    mouse.xv = 0,  mouse.yv = 0

    for (let vv of [...vvs])
    vv.mousedown()

    let m = ctx.getTransform().inverse()
    let {x: mx, y: my} = m.transformPoint(mouse)

    for (let a of atoms)
    if (dist(a.x, a.y, mx, my) < 25)
    held.obj = a

    held.obj ||= cam
}

let ui_release = () => {
    if (held.obj) {
        let xv = mouse.xv / cam.s,  yv = mouse.yv / cam.s
        if (held.obj == cam) { xv *= -1,  yv *= -1 }
        held.obj.xv = xv,  held.obj.yv = yv
        held.obj = false
    }
}

let ui_move = (x, y, dx, dy) => {
    mouse.x = x,  mouse.y = y
    mouse.xv = fri_lerp(mouse.xv, dx / dt, 0.2, dt)
    mouse.yv = fri_lerp(mouse.yv, dy / dt, 0.2, dt)

    if (held.obj == cam) {
        cam.x -= dx / cam.s
        cam.y -= dy / cam.s
        cam.xv = -mouse.xv / cam.s
        cam.yv = -mouse.yv / cam.s
    }
}

let fingers = {}
let touched = false
let touch_left = () => (
    touched !== false && !(touched in fingers)
)

onpointerdown = e => {
    let dpr = devicePixelRatio
    let x = e.clientX * dpr,  y = e.clientY * dpr

    if (e.pointerType == "touch") {
        fingers[e.pointerId] = { x, y }
        if (e.isPrimary) touched = e.pointerId
    }

    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = true
    }
    ui_press(x, y)
}

onpointerup = e => {
    if (e.pointerId in fingers)
    delete fingers[e.pointerId]

    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = false
    }
    ui_release()
}

onpointermove = e => {
    let dpr = devicePixelRatio
    let x = e.clientX * dpr,  y = e.clientY * dpr

    let pid = e.pointerId
    let ids = Object.keys(fingers)
    if (pid in fingers && ids.length == 2) {
        let {x: _x, y: _y} = fingers[pid]
        let f2 = fingers[ids[ids[0] == pid ? 1 : 0]]
        let mdx = (x - _x) / 2,  mdy = (y - _y) / 2
        let md = dist(mdx, mdy)
        let tdx = _x - f2.x,  tdy = _y - f2.y
        let td = dist(tdx, tdy)
        let dp = (mdx * tdx + mdy * tdy) / max(md * td, 0.01)
        let dpf = 1 - abs(dp)
        cam.x -= mdx * dpf / cam.s
        cam.y -= mdy * dpf / cam.s

        let d1 = dist(f2.x, f2.y, _x, _y)
        let d2 = dist(f2.x, f2.y, x, y)
        let _s = cam.s
        cam.s *= d2 / d1
        let f = 1 / _s - 1 / cam.s
        let w = canvas.width,  h = canvas.height
        cam.x += (f2.x - w / 2) * f
        cam.y += (f2.y - h / 2) * f
    }
    if (pid in fingers) fingers[pid] = { x, y }

    if (!e.isPrimary) return
    ui_move(x, y, e.movementX * dpr, e.movementY * dpr)
}

let keydown = {}

onkeydown = e => {
    let key = e.key.toLowerCase()
    if (e.repeat || e.ctrlKey) return
    keydown[key] = true

    let m = ctx.getTransform().inverse()
    let {x: mx, y: my} = m.transformPoint(mouse)

    if (key == "r") init()
    if ("df".includes(key)) ui_press(mouse.x, mouse.y)
}

onkeyup = e => {
    let key = e.key.toLowerCase()
    keydown[key] = false

    if ("df".includes(key)) ui_release()
}

let rng = (a, b) => {
    let arr = new Uint32Array(1)
    crypto.getRandomValues(arr)
    let v = arr[0] / 0xffffffff
    if (a == undefined) return v
    if (b == undefined) return v * a
    return a + v * (b - a)
}
let rngc = (r) => {
    let a = rng(2 * pi)
    return [r * cos(a), r * sin(a)]
}

let canvas = document.querySelector("canvas")
let ctx = canvas.getContext("2d")

let line = (x1, y1, x2, y2, strokeStyle) => {
    ctx.strokeStyle = strokeStyle || ctx.strokeStyle
    ctx.beginPath()
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.stroke()
}

let circle = (x, y, r, color = "SteelBlue", mode = "fill") => {
    ctx.lineWidth = 4
    if (mode == "fill") ctx.fillStyle = color
    else ctx.strokeStyle = color
    ctx.beginPath()
    ctx.ellipse(
        x, y, r, r,
        0, 0, pi * 2,
    )
    if (mode == "fill") ctx.fill()
    else ctx.stroke()
}

let _mats = []
let push = () => _mats.push(ctx.getTransform())
let pop = () => ctx.setTransform(_mats.pop())

let add_atom = fill => {
    let a = { fill, x: 0, y: 0, xv: 0, yv: 0 }
    atoms.push(a)
    return a
}

class VV {
    a = 0; s = 1
    alive = true
    open = true
    open_t = 0

    btns = {
        toggle: {
            fn: () => this.open = !this.open,
            x: 0, y: 0, fill: "#688",
        },
        rm: {
            fn: () => {
                this.open = false,  this.alive = false
                this.ts = 0
            },
            x: -65, y: 0, fill: "#122",
        },
        copy: {
            fn: () => {
                let vv2 = new VV(this.x, this.y)
                vvs.push(vv2)
                vv2.yv = rng(6000, 10000)
                vv2.xv = rng(-2000, 2000)
            },
            x: 65, y: 0, fill: "#bcd",
        },
        red: {
            fn: () => held.obj = add_atom("#a33"),
            x: cos(-2 * pi / 3) * 65, y: sin(-2 * pi / 3) * 65,
            fill: "#a33",
        },
        green: {
            fn: () => held.obj = add_atom("#285"),
            x: cos(-pi / 3) * 65, y: sin(-pi / 3) * 65,
            fill: "#285",
        },
        blue: {
            fn: () => held.obj = add_atom("#279"),
            x: cos(2 * pi / 3) * 65, y: sin(2 * pi / 3) * 65,
            fill: "#279",
        },
        none: {
            fn: () => held.obj = add_atom(),
            x: cos(pi / 3) * 65, y: sin(pi / 3) * 65,
        },
    }

    constructor(x = 0, y = 0) {
        let vv = this
        vv.x = x,  vv.y = y
        let [xv, yv] = rngc(300)
        vv.xv = xv,  vv.yv = yv
        vv.av = rng(0.2, 0.8) * sign(rng(-1, 1))
    }

    update(dt) {
        let vv = this
        vv.xv = fri_lerp(vv.xv, 0, 0.15, dt)
        vv.yv = fri_lerp(vv.yv, 0, 0.15, dt)
        vv.av = fri_lerp(vv.av, 0, 0.15, dt)
        vv.x += vv.xv * dt
        vv.y += vv.yv * dt
        vv.a += vv.av * dt

        if (vv.alive)
        vv.ts = 0.75 + 1 / (3 + exp(sqrt(vv.xv**2 + vv.yv**2) / 200))
        else if (vv.s < 0.01)
        vvs.splice(vvs.indexOf(this), 1)

        vv.s = fri_lerp(vv.s, vv.ts, 0.15, dt)

        vv.open_t = clamp(
            vv.open_t + (vv.open ? 1 : -1) * 2 * dt,
            0, 1
        )
    }

    mousedown() {
        let vv = this
        push()
        ctx.translate(vv.x, vv.y)
        ctx.rotate(vv.a)
        ctx.scale(vv.s, vv.s)

        let m = ctx.getTransform().inverse()
        let {x: mx, y: my} = m.transformPoint(mouse)

        for (let b of Object.values(vv.btns))
        if (dist(b.x, b.y, mx, my) < 25) b.fn()

        pop()
    }

    draw() {
        let vv = this
        push()
        ctx.translate(vv.x, vv.y)
        ctx.rotate(vv.a)
        ctx.scale(vv.s, vv.s)

        let slide_t = (vv.open
            ? ease.outBounce(vv.open_t)
            : 1 - ease.outBounce(1 - vv.open_t)
        )
        let roll_t = 1 - slide_t
        let h = tan(pi / 3) * 200
        let mid = tan(pi / 6) * 200

        ctx.lineWidth = 100

        push()
        ctx.translate(300 * slide_t, 0)
        ctx.rotate(-pi / 2 * roll_t)
        ctx.translate(0, -mid)
        line(-200, 0, 200, 0, "#4d3b34")
        line(-200, 0, 0, h, "#47352f")
        line(0, h, 200, 0)
        pop()

        push()
        ctx.translate(-300 * slide_t, 0)
        ctx.rotate(pi / 2 * roll_t)
        ctx.translate(0, -mid)
        line(-200, 0, 200, 0, "#4d3b34")
        line(-200, 0, 0, h, "#47352f")
        line(0, h, 200, 0)
        pop()

        let m = ctx.getTransform().inverse()
        let {x: mx, y: my} = m.transformPoint(mouse)

        for (let b of Object.values(vv.btns)) {
            let fill = b.fill
            if (dist(b.x, b.y, mx, my) < 25 && !touch_left())
            { cursor("pointer"),  fill = "#577" }
            if (fill) circle(b.x, b.y, 25, fill)
            else circle(b.x, b.y, 25, "#122", "line")
        }

        pop()
    }
}

let cam, held, vvs, atoms, bonds
let init = () => {
    cam = {
        x: 0, y: 0, xv: 0, yv: 0,
        s: canvas.width / 1600,
    }
    held = {}
    vvs = [new VV(0, -30)]
    atoms = []
    bonds = new Map()
}

onload = () => {
    init()
    loop()
}

onresize = () => {
    let dpr = devicePixelRatio
    let w = innerWidth * dpr,  h = innerHeight * dpr
    if (cam) cam.s *= w / canvas.width
    canvas.width = w,  canvas.height = h
}
onresize()

let update = dt => {
    mouse.xv = fri_lerp(mouse.xv, 0, 0.3, dt)
    mouse.yv = fri_lerp(mouse.yv, 0, 0.3, dt)
    if (held.obj != cam) {
        cam.xv = fri_lerp(cam.xv, 0, 0.05, dt)
        cam.yv = fri_lerp(cam.yv, 0, 0.05, dt)
        cam.x += cam.xv * dt
        cam.y += cam.yv * dt
    }

    if (!vvs.length) vvs = [new VV(0, -30)]
    for (let vv of [...vvs]) vv.update(dt)

    let m = ctx.getTransform().inverse()
    let {x: mx, y: my} = m.transformPoint(mouse)

    let h = held.obj
    if (h && h != cam) { h.x = mx,  h.y = my }

    for (let a of atoms)
    if (a != h) {
        a.xv = fri_lerp(a.xv, 0, 0.1, dt)
        a.yv = fri_lerp(a.yv, 0, 0.1, dt)
        a.x += a.xv * dt
        a.y += a.yv * dt
    }
}

let draw = () => {
    ctx.resetTransform()
    let w = canvas.width,  h = canvas.height
    ctx.clearRect(0, 0, w, h)
    cursor("default")

    ctx.translate(w / 2, h / 2)
    ctx.scale(cam.s, cam.s)
    ctx.translate(-cam.x, -cam.y)
    push()

    ctx.lineCap = "round"
    ctx.lineJoin = "round"
    for (let vv of vvs) vv.draw()

    let m = ctx.getTransform().inverse()
    let {x: mx, y: my} = m.transformPoint(mouse)

    for (let a of atoms) {
        let fill = a.fill
        if (dist(a.x, a.y, mx, my) < 25 && !touch_left())
        { cursor("pointer"),  fill = "#577" }
        if (fill) circle(a.x, a.y, 25, fill)
        else circle(a.x, a.y, 25, "#122", "line")
    }

    pop()
}

let now = () => performance.now()
let _time = now()
let dt = 0

let loop = () => {
    dt = min((now() - _time) / 1000, 0.1)
    _time = now()

    update(dt)
    draw()

    requestAnimationFrame(loop)
}
</script>
</body>
</html>
