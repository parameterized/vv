<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>vv</title>
<link rel="shortcut icon" href='data:image/svg+xml,
    <svg xmlns=%22http://www.w3.org/2000/svg" viewBox="0 0 100 100">
    <text y="1.1em" font-size="75">üå±Ô∏è</text></svg>'>
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<style>
    * { box-sizing: border-box; }
    body {
        margin: 0;
        overflow: hidden;
        background: #523f38;
    }
    canvas { position: absolute; }
</style>
</head>

<body>
<canvas ondragstart="return false"></canvas>
<script>
let { min, max, exp, sin, cos, atan2 } = Math
let pi = Math.PI

let lerp = (a, b, t) => a * (1 - t) + b * t
let clamp = (x, a, b) => min(max(x, a), b)

let mouse = {
    x: 0, y: 0,
    held: { 0: false, 1: false, 2: false },
    moved: false,
}
mouse_held = btn => {
    if (btn == undefined) {
        for (let b in mouse.held)
        if (mouse.held[b]) return true
        return false
    }
    return btn in mouse.held && mouse.held[btn]
}
onpointermove = e => {
    if (!e.isPrimary) return
    mouse.x = e.clientX
    mouse.y = e.clientY
    mouse.moved = true

    if (keydown.f || mouse_held(2)) {
        cam.x -= e.movementX / cam.s
        cam.y -= e.movementY / cam.s
    }
}
onwheel = e => {
    let _s = cam.s
    cam.s *= exp(-e.deltaY / 1000)
    let f = 1 / _s - 1 / cam.s
    let [w, h] = [innerWidth, innerHeight]
    cam.x += (mouse.x - w / 2) * f
    cam.y += (mouse.y - h / 2) * f
}
oncontextmenu = e => e.preventDefault()
onpointerdown = e => {
    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = true
    }
    mouse.x = e.clientX
    mouse.y = e.clientY
    mouse.moved = true
}
onpointerup = e => {
    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = false
    }
}

let keydown = {}
onkeydown = e => {
    let key = e.key.toLowerCase()
    if (e.repeat || e.ctrlKey) return
    keydown[key] = true

    switch (key) {
        case "r": init(); break
    }
}
onkeyup = e => {
    let key = e.key.toLowerCase()
    keydown[key] = false
}

let rng = (a, b) => {
    let arr = new Uint32Array(1)
    crypto.getRandomValues(arr)
    let v = arr[0] / 0xffffffff
    if (a == undefined) return v
    if (b == undefined) return v * a
    return a + v * (b - a)
}

let canvas = document.querySelector("canvas")
let ctx = canvas.getContext("2d")

let cam

let new_vert = v => [
    v[0] + rng(-30, 30),
    v[1] + rng(-30, 30),
]

let init = () => {
    cam = { x: 0, y: 0, s: 1 }
}

onload = () => {
    init()
    loop()
}

onresize = () => {
    canvas.width = innerWidth
    canvas.height = innerHeight
}
onresize()

let circle = (x, y, r, fillStyle = "SteelBlue") => {
    ctx.fillStyle = fillStyle
    ctx.beginPath()
    ctx.ellipse(
        x, y, r, r,
        0, 0, pi * 2,
    )
    ctx.fill()
}

let update = dt => {
}

let draw = () => {
    let [w, h] = [innerWidth, innerHeight]
    ctx.clearRect(0, 0, w, h)

    let _mat = ctx.getTransform()
    ctx.translate(w / 2, h / 2)
    ctx.scale(cam.s, cam.s)
    ctx.translate(-cam.x, -cam.y)

    ctx.lineWidth = 100
    ctx.lineCap = "round"
    ctx.lineJoin = "round"
    ctx.strokeStyle = "#4d3b34"
    ctx.beginPath()
    ctx.moveTo(-500, -200)
    ctx.lineTo(-100, -200)
    ctx.moveTo(-60, 0)
    ctx.lineTo(60, 0)
    ctx.moveTo(100, -200)
    ctx.lineTo(500, -200)
    ctx.stroke()
    ctx.strokeStyle = "#47352f"
    ctx.beginPath()
    ctx.moveTo(-500, -200)
    ctx.lineTo(-300, 200)
    ctx.lineTo(-100, -200)
    ctx.moveTo(100, -200)
    ctx.lineTo(300, 200)
    ctx.lineTo(500, -200)
    ctx.stroke()

    circle(-60, 0, 25, "#122")
    circle(0, 0, 25, "#688")
    circle(60, 0, 25, "#bcd")

    ctx.lineWidth = 2

    ctx.setTransform(_mat)
}

let now = () => performance.now()
let _time = now()

let loop = () => {
    let dt = min((now() - _time) / 1000, 0.1)
    _time = now()

    update(dt)
    draw()

    requestAnimationFrame(loop)
}
</script>
</body>
</html>
