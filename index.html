<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>vv</title>
<link rel="shortcut icon" href='data:image/svg+xml,
    <svg xmlns=%22http://www.w3.org/2000/svg" viewBox="0 0 100 100">
    <text y="1.1em" font-size="75">üå±Ô∏è</text></svg>'>
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<style>
    * { box-sizing: border-box; }
    body {
        margin: 0;
        overflow: hidden;
        background: #523f38;
        touch-action: pinch-zoom;
    }
    canvas {
        position: absolute;
        display: block;
        width: 100dvw;
        height: 100dvh;
        -webkit-tap-highlight-color: transparent;
    }
</style>
</head>

<body>
<canvas ondragstart="return false"></canvas>
<script>
let { min, max, abs, sign, sqrt, exp, sin, cos, tan, atan2 } = Math
let pi = Math.PI

let clamp = (x, a, b) => min(max(x, a), b)
let dist = (x1, y1, x2, y2) => sqrt((x2 - x1)**2 + (y2 - y1)**2)
let lerp = (a, b, t) => a * (1 - t) + b * t
let fri_lerp = (a, b, t, dt) => {
    let alpha = 1 - exp(-60 * t * dt)
    return lerp(a, b, alpha)
}

let ease = {
    outQuad: t => t * (2 - t),
    outBounce: t => {
        let n1 = 7.5625,  d1 = 2.75
        if (t < 1 / d1) return n1 * t * t
        else if (t < 2 / d1)
            return n1 * (t -= 1.5 / d1) * t + 0.75
        else if (t < 2.5 / d1)
            return n1 * (t -= 2.25 / d1) * t + 0.9375
        else return n1 * (t -= 2.625 / d1) * t + 0.984375
    }
}

let cursor = v => document.body.style.cursor = v

let mouse = {
    x: 0, y: 0,
    held: { 0: false, 1: false, 2: false },
    moved: false,
}
mouse_held = btn => {
    if (btn == undefined) {
        for (let b in mouse.held)
        if (mouse.held[b]) return true
        return false
    }
    return btn in mouse.held && mouse.held[btn]
}
onpointermove = e => {
    if (!e.isPrimary) return
    mouse.x = e.clientX * devicePixelRatio
    mouse.y = e.clientY * devicePixelRatio
    mouse.moved = true

    if (keydown.f || mouse_held(2)) {
        cam.x -= e.movementX / cam.s
        cam.y -= e.movementY / cam.s
    }
}
onwheel = e => {
    let _s = cam.s
    cam.s *= exp(-e.deltaY / 1000)
    let f = 1 / _s - 1 / cam.s
    let [w, h] = [canvas.width, canvas.height]
    cam.x += (mouse.x - w / 2) * f
    cam.y += (mouse.y - h / 2) * f
}
oncontextmenu = e => e.preventDefault()
onpointerdown = e => {
    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = true
    }
    mouse.x = e.clientX * devicePixelRatio
    mouse.y = e.clientY * devicePixelRatio
    mouse.moved = true

    for (let vv of [...vvs])
    if (e.button == 0) vv.mousedown()

    let m = ctx.getTransform().inverse()
    let {x, y} = m.transformPoint(mouse)

    for (let a of atoms)
    if (dist(a.x, a.y, x, y) < 25)
    held_atom = a
}
onpointerup = e => {
    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = false
    }

    held_atom = null
}

let keydown = {}
onkeydown = e => {
    let key = e.key.toLowerCase()
    if (e.repeat || e.ctrlKey) return
    keydown[key] = true

    let m = ctx.getTransform().inverse()
    let {x, y} = m.transformPoint(mouse)

    switch (key) {
        case "r": init(); break
        case "d": {
            for (let a of atoms)
            if (dist(a.x, a.y, x, y) < 25)
            held_atom = a
            break
        }
    }
    for (let vv of [...vvs]) vv.keydown(key)
}
onkeyup = e => {
    let key = e.key.toLowerCase()
    keydown[key] = false

    held_atom = null
}

let rng = (a, b) => {
    let arr = new Uint32Array(1)
    crypto.getRandomValues(arr)
    let v = arr[0] / 0xffffffff
    if (a == undefined) return v
    if (b == undefined) return v * a
    return a + v * (b - a)
}
let rngc = (r) => {
    let a = rng(2 * pi)
    return [r * cos(a), r * sin(a)]
}

let canvas = document.querySelector("canvas")
let ctx = canvas.getContext("2d")

let line = (x1, y1, x2, y2, strokeStyle) => {
    ctx.strokeStyle = strokeStyle || ctx.strokeStyle
    ctx.beginPath()
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.stroke()
}

let circle = (x, y, r, color = "SteelBlue", mode = "fill") => {
    ctx.lineWidth = 4
    if (mode == "fill") ctx.fillStyle = color
    else ctx.strokeStyle = color
    ctx.beginPath()
    ctx.ellipse(
        x, y, r, r,
        0, 0, pi * 2,
    )
    if (mode == "fill") ctx.fill()
    else ctx.stroke()
}

let _mats = []
let push = () => _mats.push(ctx.getTransform())
let pop = () => ctx.setTransform(_mats.pop())

let cam, vvs, atoms, bonds
let held_atom

let add_atom = fill => {
    let a = { fill }
    atoms.push(a)
    return a
}

class VV {
    a = 0; s = 1
    alive = true
    open = true
    open_t = 0

    btns = {
        toggle: {
            fn: () => this.open = !this.open,
            x: 0, y: 0, fill: "#688",
        },
        rm: {
            fn: () => {
                this.open = false,  this.alive = false
                this.ts = 0
            },
            x: -65, y: 0, fill: "#122",
        },
        copy: {
            fn: () => {
                let vv2 = new VV(this.x, this.y)
                vvs.push(vv2)
                vv2.yv = rng(6000, 10000)
                vv2.xv = rng(-2000, 2000)
            },
            x: 65, y: 0, fill: "#bcd",
        },
        red: {
            fn: () => held_atom = add_atom("#a33"),
            x: cos(-2 * pi / 3) * 65, y: sin(-2 * pi / 3) * 65,
            fill: "#a33",
        },
        green: {
            fn: () => held_atom = add_atom("#285"),
            x: cos(-pi / 3) * 65, y: sin(-pi / 3) * 65,
            fill: "#285",
        },
        blue: {
            fn: () => held_atom = add_atom("#279"),
            x: cos(2 * pi / 3) * 65, y: sin(2 * pi / 3) * 65,
            fill: "#279",
        },
        none: {
            fn: () => held_atom = add_atom(),
            x: cos(pi / 3) * 65, y: sin(pi / 3) * 65,
        },
    }

    constructor(x = 0, y = 0) {
        let vv = this
        vv.x = x,  vv.y = y
        let [xv, yv] = rngc(300)
        vv.xv = xv,  vv.yv = yv
        vv.av = rng(0.2, 0.8) * sign(rng(-1, 1))
    }

    update(dt) {
        let vv = this
        vv.xv = fri_lerp(vv.xv, 0, 0.15, dt)
        vv.yv = fri_lerp(vv.yv, 0, 0.15, dt)
        vv.av = fri_lerp(vv.av, 0, 0.15, dt)
        vv.x += vv.xv * dt
        vv.y += vv.yv * dt
        vv.a += vv.av * dt

        if (vv.alive)
        vv.ts = 0.75 + 1 / (3 + exp(sqrt(vv.xv**2 + vv.yv**2) / 200))
        else if (vv.s < 0.01)
        vvs.splice(vvs.indexOf(this), 1)

        vv.s = fri_lerp(vv.s, vv.ts, 0.15, dt)

        vv.open_t = clamp(
            vv.open_t + (vv.open ? 1 : -1) * 2 * dt,
            0, 1
        )
    }

    mousedown() {
        let vv = this
        push()
        ctx.translate(vv.x, vv.y)
        ctx.rotate(vv.a)
        ctx.scale(vv.s, vv.s)

        let m = ctx.getTransform().inverse()
        let {x, y} = m.transformPoint(mouse)

        for (let b of Object.values(vv.btns))
        if (dist(x, y, b.x, b.y) < 25) b.fn()

        pop()
    }

    keydown(key) {
        if (key != "d") return
        this.mousedown()
    }

    draw() {
        let vv = this
        push()
        ctx.translate(vv.x, vv.y)
        ctx.rotate(vv.a)
        ctx.scale(vv.s, vv.s)

        let slide_t = (vv.open
            ? ease.outBounce(vv.open_t)
            : 1 - ease.outBounce(1 - vv.open_t)
        )
        let roll_t = 1 - slide_t
        let h = tan(pi / 3) * 200
        let mid = tan(pi / 6) * 200

        ctx.lineWidth = 100

        push()
        ctx.translate(300 * slide_t, 0)
        ctx.rotate(-pi / 2 * roll_t)
        ctx.translate(0, -mid)
        line(-200, 0, 200, 0, "#4d3b34")
        line(-200, 0, 0, h, "#47352f")
        line(0, h, 200, 0)
        pop()

        push()
        ctx.translate(-300 * slide_t, 0)
        ctx.rotate(pi / 2 * roll_t)
        ctx.translate(0, -mid)
        line(-200, 0, 200, 0, "#4d3b34")
        line(-200, 0, 0, h, "#47352f")
        line(0, h, 200, 0)
        pop()

        let m = ctx.getTransform().inverse()
        let {x, y} = m.transformPoint(mouse)

        for (let b of Object.values(vv.btns)) {
            let fill = b.fill
            if (dist(x, y, b.x, b.y) < 25)
            { cursor("pointer"),  fill = "#577" }
            if (fill) circle(b.x, b.y, 25, fill)
            else circle(b.x, b.y, 25, "#122", "line")
        }

        pop()
    }
}

let init = () => {
    cam = { x: 0, y: 0, s: canvas.width / 1600 }
    vvs = [new VV()]
    atoms = []
    bonds = new Map()
}

onload = () => {
    init()
    loop()
}

onresize = () => {
    let dpr = devicePixelRatio
    let [w, h] = [innerWidth * dpr, innerHeight * dpr]
    if (cam) cam.s *= w / canvas.width
    ;[canvas.width, canvas.height] = [w, h]
}
onresize()

let update = dt => {
    if (!vvs.length) vvs = [new VV()]
    for (let vv of [...vvs]) vv.update(dt)

    let m = ctx.getTransform().inverse()
    let {x, y} = m.transformPoint(mouse)

    let a = held_atom
    if (a) { a.x = x,  a.y = y }
}

let draw = () => {
    ctx.resetTransform()
    let [w, h] = [canvas.width, canvas.height]
    ctx.clearRect(0, 0, w, h)
    cursor("default")

    ctx.translate(w / 2, h / 2)
    ctx.scale(cam.s, cam.s)
    ctx.translate(-cam.x, -cam.y)
    push()

    ctx.lineCap = "round"
    ctx.lineJoin = "round"
    for (let vv of vvs) vv.draw()

    let m = ctx.getTransform().inverse()
    let {x, y} = m.transformPoint(mouse)

    for (let a of atoms) {
        let fill = a.fill
        if (dist(a.x, a.y, x, y) < 25)
        { cursor("pointer"),  fill = "#577" }
        if (fill) circle(a.x, a.y, 25, fill)
        else circle(a.x, a.y, 25, "#122", "line")
    }

    pop()
}

let now = () => performance.now()
let _time = now()

let loop = () => {
    let dt = min((now() - _time) / 1000, 0.1)
    _time = now()

    update(dt)
    draw()

    requestAnimationFrame(loop)
}
</script>
</body>
</html>
